INTRO

A common problem amoung developers working in teams or even students learning about tree diagrams and linked lists is learning how to use them as it can be rather confusing. Normally developers and students learning about tree diagrams and linked list have to make them testing different traversal types manually to see what results they give.
This software has been developed to address these problems. The app is designed to provide an easy to understand and use interface for creating, testing and calculating tree diagrams and linked lists. This makes not only creating the diagrams easier but also learning them a lot more simple and understandable, saving time and helping users.
This software was designed through different sections of code allocation to the members and different sections. The software is completely programmed in C++ using the Visual Studio IDE, using a variety of different libraries such as SDL to process graphics i.e. the GUI and displaying the tree and linked list diagrams.
There are currently  a few other types of software/websites out there that provide a similar service as our software. Smartdraw provides an easy to use free online tree diagram builder, however it doesn't allow for various traversal types to be ran and to gather the results from said traversal types being ran. Our software also generates tree diagrams and linked lists, making it easier to learn about them and understand why certain results are given. Our software has similar aspects as a lot of software already existing, but brings it all together in a nice, easy to use and understand piece of software.

AIM

To design and create a piece of software that allows users to create, test and generate tree diagrams and linked lists, while providing an easy to undertand and use GUI. The software must be user friendly, but remain professional and complete its full purpose successfully.

OBJECTIVES

The following list of objectives have been compiled down and applied to our project to ensure all of the desired outcomes and needs of the software are met:
The design of the software must be user friendly.
The deisgn of the software must be easy to understand, clear all while remaining professional.
User must be able to choose between Binary tree or linked list.
User must be able to add text to the tree nodes/linked list.
User must be able to enter a traversal type for the generator.
Easy to follow and understand menus.
Must be able to display the possible value for the nodes.


REQUIERMENTS SPECIFICATION

For the requirements specification we used UML (Unified Modelling Language) including, use case diagrams, Activity/ Sequence Diagrams, Class Diagrams. 

USE CASE

The below use case shows the possible actions and interactions the user will be making with the system, this includes option paths and actions and interactions of which lead to more possible interactions and actions until the end goal is achieved and the user is finished using the system.

<Diagram goes here>

ACTIVITY DIAGRAM

The activity diagram shown below is used to show the flow from one activity to another, similar to a flow chart, each activity an ‘operation’ of the system and the flow normally involving input from the user.

<Diagram goes here>

SEQUENCE DIAGRAM

The sequence diagram, shown below, is used to show how the different objects within the system interact with each other in time sequence. Depicting the objects and classes and the messages sent between them needed to carry out the functionality of the scenario in question.

<Diagram goes here>

CLASS DIAGRAM

The class diagram shown below shows the static structure of the system, by showing the classes within our system, their attributes and operations (Methods in this case), and the relationship among the classes.

<Diagram goes here>

OUR ADOPTED APPROACH
We decided to use the ‘AGILE’ software development life cycle throughout the creation of this software. Agile involves a specific process flow of working, the project is first envisioned and priorities are figured out as to decide of which order things should be done, in our case, because we were working in a group we split off into different areas of the software programming, meaning priorities were also decided on which of the classes also relied on other classes, to priorities the order of the classes to be developed.
